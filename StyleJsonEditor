#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Style JSON Editor (PyQt6)
- style.json の読み込み / 保存（dict形式・list形式の双方に対応）
- スタイル項目（name, positive, negative）の追加・複製・削除・順序入れ替え
- フォルダダイアログでパス選択、画像ファイル有無をバリデーション
- 画像枚数をクイック集計（正/負）
- 保存時は dict 形式（{name: {positive, negative}}）で出力（設定で list 形式も選択可）

依存: PyQt6（標準lib: os, sys, json, glob）
"""

import os
import sys
import json
import glob
from typing import List, Dict, Tuple, Any

from PyQt6 import QtWidgets, QtGui, QtCore
from PyQt6.QtCore import Qt

_VALID_IMG_EXTS = (".jpg", ".jpeg", ".png", ".bmp", ".webp")

def has_images(folder: str) -> bool:
    if not os.path.isdir(folder):
        return False
    for ext in _VALID_IMG_EXTS:
        if glob.glob(os.path.join(folder, f"*{ext}")):
            return True
    return False

def count_images(folder: str) -> int:
    if not os.path.isdir(folder):
        return 0
    total = 0
    for ext in _VALID_IMG_EXTS:
        total += len(glob.glob(os.path.join(folder, f"*{ext}")))
    return total

def normalize_loaded_json(data: Any, base_dir: str) -> List[Dict[str, str]]:
    """
    読み込んだ JSON（dict or list）を内部の統一形式:
    [{'name': str, 'positive': str, 'negative': str}] に正規化。
    相対パスは base_dir を基準に絶対パス化する。
    """
    items = []
    if isinstance(data, dict):
        for name, spec in data.items():
            if not (isinstance(spec, dict) and "positive" in spec and "negative" in spec):
                raise ValueError(f"不正な形式: {name} に 'positive'/'negative' がありません。")
            pos = spec["positive"]
            neg = spec["negative"]
            pos = os.path.abspath(os.path.join(base_dir, pos)) if not os.path.isabs(pos) else pos
            neg = os.path.abspath(os.path.join(base_dir, neg)) if not os.path.isabs(neg) else neg
            items.append({"name": str(name), "positive": pos, "negative": neg})
    elif isinstance(data, list):
        for i, it in enumerate(data):
            if not (isinstance(it, dict) and all(k in it for k in ("name", "positive", "negative"))):
                raise ValueError(f"不正な形式: index={i} に 'name'/'positive'/'negative' がありません。")
            pos = it["positive"]
            neg = it["negative"]
            pos = os.path.abspath(os.path.join(base_dir, pos)) if not os.path.isabs(pos) else pos
            neg = os.path.abspath(os.path.join(base_dir, neg)) if not os.path.isabs(neg) else neg
            items.append({"name": str(it["name"]), "positive": pos, "negative": neg})
    else:
        raise ValueError("JSONルートはオブジェクト（dict）または配列（list）にしてください。")
    return items

def export_as_dict(items: List[Dict[str, str]], base_dir: str, make_relative: bool) -> Dict[str, Dict[str, str]]:
    """
    内部形式を { name: {positive, negative} } に変換。
    make_relative=True のとき base_dir に対して相対パスにする。
    """
    out = {}
    for it in items:
        name = it["name"]
        pos = it["positive"]
        neg = it["negative"]
        if make_relative:
            pos = os.path.relpath(pos, base_dir)
            neg = os.path.relpath(neg, base_dir)
        out[name] = {"positive": pos, "negative": neg}
    return out

def export_as_list(items: List[Dict[str, str]], base_dir: str, make_relative: bool) -> List[Dict[str, str]]:
    """
    内部形式を [{'name', 'positive', 'negative'}] に変換。
    make_relative=True のとき base_dir に対して相対パスにする。
    """
    out = []
    for it in items:
        pos = it["positive"]
        neg = it["negative"]
        if make_relative:
            pos = os.path.relpath(pos, base_dir)
            neg = os.path.relpath(neg, base_dir)
        out.append({"name": it["name"], "positive": pos, "negative": neg})
    return out

class StylesModel(QtCore.QAbstractTableModel):
    HEADERS = ["Name", "Positive Folder", "Negative Folder", "Pos Images", "Neg Images"]

    def __init__(self, parent=None):
        super().__init__(parent)
        self._items: List[Dict[str, str]] = []

    # ---- basic model API ----
    def rowCount(self, parent=QtCore.QModelIndex()) -> int:
        return len(self._items)

    def columnCount(self, parent=QtCore.QModelIndex()) -> int:
        return len(self.HEADERS)

    def data(self, index: QtCore.QModelIndex, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None
        r, c = index.row(), index.column()
        item = self._items[r]

        if role in (Qt.ItemDataRole.DisplayRole, Qt.ItemDataRole.EditRole):
            if c == 0:
                return item["name"]
            elif c == 1:
                return item["positive"]
            elif c == 2:
                return item["negative"]
            elif c == 3:
                return str(count_images(item["positive"])) if os.path.isdir(item["positive"]) else "-"
            elif c == 4:
                return str(count_images(item["negative"])) if os.path.isdir(item["negative"]) else "-"
        if role == Qt.ItemDataRole.ToolTipRole:
            if c in (1, 2):
                return item["positive"] if c == 1 else item["negative"]
        return None

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        if role == Qt.ItemDataRole.DisplayRole and orientation == Qt.Orientation.Horizontal:
            return self.HEADERS[section]
        return None

    def flags(self, index):
        if not index.isValid():
            return Qt.ItemFlag.ItemIsEnabled
        flags = Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        if index.column() in (0, 1, 2):
            flags |= Qt.ItemFlag.ItemIsEditable
        return flags

    def setData(self, index, value, role=Qt.ItemDataRole.EditRole):
        if not index.isValid() or role != Qt.ItemDataRole.EditRole:
            return False
        r, c = index.row(), index.column()
        value = str(value)
        if c == 0:
            self._items[r]["name"] = value
        elif c == 1:
            self._items[r]["positive"] = value
        elif c == 2:
            self._items[r]["negative"] = value
        else:
            return False
        self.dataChanged.emit(index, index, [Qt.ItemDataRole.DisplayRole, Qt.ItemDataRole.EditRole])
        # 画像枚数セルも更新
        self.dataChanged.emit(self.index(r, 3), self.index(r, 4), [Qt.ItemDataRole.DisplayRole])
        return True

    # ---- helpers ----
    def items(self) -> List[Dict[str, str]]:
        return self._items

    def set_items(self, items: List[Dict[str, str]]):
        self.beginResetModel()
        self._items = items[:]
        self.endResetModel()

    def add_item(self, name: str = "new_style", pos: str = "", neg: str = ""):
        self.beginInsertRows(QtCore.QModelIndex(), len(self._items), len(self._items))
        self._items.append({"name": name, "positive": pos, "negative": neg})
        self.endInsertRows()

    def duplicate_row(self, row: int):
        if 0 <= row < len(self._items):
            it = dict(self._items[row])
            it["name"] = it["name"] + "_copy"
            self.beginInsertRows(QtCore.QModelIndex(), row + 1, row + 1)
            self._items.insert(row + 1, it)
            self.endInsertRows()

    def remove_row(self, row: int):
        if 0 <= row < len(self._items):
            self.beginRemoveRows(QtCore.QModelIndex(), row, row)
            del self._items[row]
            self.endRemoveRows()

    def move_up(self, row: int):
        if 1 <= row < len(self._items):
            self.beginMoveRows(QtCore.QModelIndex(), row, row, QtCore.QModelIndex(), row - 1)
            self._items[row - 1], self._items[row] = self._items[row], self._items[row - 1]
            self.endMoveRows()

    def move_down(self, row: int):
        if 0 <= row < len(self._items) - 1:
            self.beginMoveRows(QtCore.QModelIndex(), row, row, QtCore.QModelIndex(), row + 2)
            self._items[row], self._items[row + 1] = self._items[row + 1], self._items[row]
            self.endMoveRows()

class PathEdit(QtWidgets.QWidget):
    """
    パス用の編集ウィジェット（行選択に対して、positive/negative を個別に変更する補助）
    """
    pathChanged = QtCore.pyqtSignal(str)

    def __init__(self, label_text: str, parent=None):
        super().__init__(parent)
        lay = QtWidgets.QHBoxLayout(self)
        lay.setContentsMargins(0, 0, 0, 0)
        self.label = QtWidgets.QLabel(label_text)
        self.edit = QtWidgets.QLineEdit()
        self.btn = QtWidgets.QPushButton("参照...")
        self.btn.clicked.connect(self.browse)
        lay.addWidget(self.label)
        lay.addWidget(self.edit, 1)
        lay.addWidget(self.btn)

    def setText(self, text: str):
        self.edit.setText(text)

    def text(self) -> str:
        return self.edit.text()

    def browse(self):
        d = QtWidgets.QFileDialog.getExistingDirectory(self, "フォルダを選択")
        if d:
            self.edit.setText(d)
            self.pathChanged.emit(d)

class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Style JSON Editor")
        self.resize(1100, 680)

        self._json_path: str = ""
        self._base_dir_for_save: str = ""  # 保存時の相対基準
        self._save_as_list: bool = False
        self._save_relative: bool = True

        # central UI
        central = QtWidgets.QWidget(self)
        self.setCentralWidget(central)
        h = QtWidgets.QHBoxLayout(central)

        # left: table + controls
        left = QtWidgets.QWidget()
        vleft = QtWidgets.QVBoxLayout(left)

        self.table = QtWidgets.QTableView()
        self.model = StylesModel(self)
        self.table.setModel(self.model)
        self.table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.table.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.verticalHeader().setVisible(False)
        self.table.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.DoubleClicked | QtWidgets.QAbstractItemView.EditTrigger.SelectedClicked)
        vleft.addWidget(self.table, 1)

        btns = QtWidgets.QHBoxLayout()
        self.btn_add = QtWidgets.QPushButton("追加")
        self.btn_dup = QtWidgets.QPushButton("複製")
        self.btn_del = QtWidgets.QPushButton("削除")
        self.btn_up  = QtWidgets.QPushButton("上へ")
        self.btn_down= QtWidgets.QPushButton("下へ")
        btns.addWidget(self.btn_add); btns.addWidget(self.btn_dup); btns.addWidget(self.btn_del)
        btns.addStretch(1); btns.addWidget(self.btn_up); btns.addWidget(self.btn_down)
        vleft.addLayout(btns)

        # right: editor panel
        right = QtWidgets.QGroupBox("選択中のスタイルを編集")
        form = QtWidgets.QFormLayout(right)

        self.edit_name = QtWidgets.QLineEdit()
        self.path_pos = PathEdit("positive:")
        self.path_neg = PathEdit("negative:")

        # quick counts
        cnt_row = QtWidgets.QHBoxLayout()
        self.lbl_pos_count = QtWidgets.QLabel("pos: -")
        self.lbl_neg_count = QtWidgets.QLabel("neg: -")
        btn_recount = QtWidgets.QPushButton("枚数更新")
        btn_recount.clicked.connect(self.update_counts_for_selection)
        cnt_row.addWidget(self.lbl_pos_count)
        cnt_row.addWidget(self.lbl_neg_count)
        cnt_row.addStretch(1)
        cnt_row.addWidget(btn_recount)

        # validate buttons
        val_row = QtWidgets.QHBoxLayout()
        self.btn_validate = QtWidgets.QPushButton("選択行を検証")
        self.btn_validate_all = QtWidgets.QPushButton("全行を検証")
        val_row.addWidget(self.btn_validate)
        val_row.addWidget(self.btn_validate_all)

        form.addRow("name:", self.edit_name)
        form.addRow(self.path_pos)
        form.addRow(self.path_neg)
        form.addRow("画像枚数:", cnt_row)
        form.addRow(val_row)

        # save options
        opt_box = QtWidgets.QGroupBox("保存オプション")
        opt = QtWidgets.QFormLayout(opt_box)
        self.chk_save_list = QtWidgets.QCheckBox("list 形式で保存（未チェック: dict 形式）")
        self.chk_relative  = QtWidgets.QCheckBox("基準フォルダに対して相対パスで保存")
        self.chk_relative.setChecked(True)
        self.btn_set_base  = QtWidgets.QPushButton("基準フォルダを設定…")
        self.lbl_base_dir  = QtWidgets.QLabel("(未設定 → 現在の style.json の場所)")
        opt.addRow(self.chk_save_list)
        opt.addRow(self.chk_relative)
        opt.addRow(self.btn_set_base, self.lbl_base_dir)

        # layout join
        h.addWidget(left, 1)
        right_wrap = QtWidgets.QWidget()
        vr = QtWidgets.QVBoxLayout(right_wrap)
        vr.addWidget(right)
        vr.addWidget(opt_box)
        h.addWidget(right_wrap, 0)

        # status & menu
        self.statusBar().showMessage("準備完了")
        self._build_menu()

        # signals
        self.table.selectionModel().selectionChanged.connect(self.on_selection_changed)
        self.edit_name.textEdited.connect(self.on_field_changed)
        self.path_pos.pathChanged.connect(self.on_field_changed)
        self.path_pos.edit.textEdited.connect(self.on_field_changed)
        self.path_neg.pathChanged.connect(self.on_field_changed)
        self.path_neg.edit.textEdited.connect(self.on_field_changed)

        self.btn_add.clicked.connect(self.on_add)
        self.btn_dup.clicked.connect(self.on_duplicate)
        self.btn_del.clicked.connect(self.on_delete)
        self.btn_up.clicked.connect(self.on_up)
        self.btn_down.clicked.connect(self.on_down)

        self.btn_validate.clicked.connect(self.on_validate_one)
        self.btn_validate_all.clicked.connect(self.on_validate_all)

        self.chk_save_list.toggled.connect(self.on_save_option_changed)
        self.chk_relative.toggled.connect(self.on_save_option_changed)
        self.btn_set_base.clicked.connect(self.on_set_base_dir)

    # ---- menu ----
    def _build_menu(self):
        mb = self.menuBar()
        m_file = mb.addMenu("ファイル")
        act_new = m_file.addAction("新規")
        act_open = m_file.addAction("開く…")
        act_save = m_file.addAction("上書き保存")
        act_saveas = m_file.addAction("名前を付けて保存…")
        m_file.addSeparator()
        act_quit = m_file.addAction("終了")

        act_new.triggered.connect(self.on_new)
        act_open.triggered.connect(self.on_open)
        act_save.triggered.connect(self.on_save)
        act_saveas.triggered.connect(self.on_save_as)
        act_quit.triggered.connect(self.close)

    # ---- helpers ----
    def current_row(self) -> int:
        sel = self.table.selectionModel().selectedRows()
        return sel[0].row() if sel else -1

    def pull_editor_to_model(self):
        r = self.current_row()
        if r < 0:
            return
        self.model.setData(self.model.index(r, 0), self.edit_name.text())
        self.model.setData(self.model.index(r, 1), self.path_pos.text())
        self.model.setData(self.model.index(r, 2), self.path_neg.text())

    def push_model_to_editor(self, row: int):
        if row < 0 or row >= self.model.rowCount():
            self.edit_name.setText("")
            self.path_pos.setText("")
            self.path_neg.setText("")
            self.lbl_pos_count.setText("pos: -")
            self.lbl_neg_count.setText("neg: -")
            return
        it = self.model.items()[row]
        self.edit_name.setText(it["name"])
        self.path_pos.setText(it["positive"])
        self.path_neg.setText(it["negative"])
        self.update_counts_for_selection()

    def update_counts_for_selection(self):
        r = self.current_row()
        if r < 0:
            self.lbl_pos_count.setText("pos: -")
            self.lbl_neg_count.setText("neg: -")
            return
        it = self.model.items()[r]
        self.lbl_pos_count.setText(f"pos: {count_images(it['positive'])}" if os.path.isdir(it["positive"]) else "pos: (not dir)")
        self.lbl_neg_count.setText(f"neg: {count_images(it['negative'])}" if os.path.isdir(it["negative"]) else "neg: (not dir)")

    # ---- events ----
    def on_selection_changed(self):
        self.push_model_to_editor(self.current_row())

    def on_field_changed(self):
        self.pull_editor_to_model()
        self.update_counts_for_selection()

    def on_add(self):
        self.model.add_item()
        last = self.model.rowCount() - 1
        self.table.selectRow(last)
        self.statusBar().showMessage("スタイルを追加しました。")

    def on_duplicate(self):
        r = self.current_row()
        if r >= 0:
            self.model.duplicate_row(r)
            self.table.selectRow(r + 1)
            self.statusBar().showMessage("複製しました。")

    def on_delete(self):
        r = self.current_row()
        if r >= 0:
            name = self.model.items()[r]["name"]
            ok = QtWidgets.QMessageBox.question(self, "確認", f"選択中のスタイルを削除しますか？\n{name}")
            if ok == QtWidgets.QMessageBox.StandardButton.Yes:
                self.model.remove_row(r)
                self.statusBar().showMessage("削除しました。")

    def on_up(self):
        r = self.current_row()
        if r > 0:
            self.model.move_up(r)
            self.table.selectRow(r - 1)

    def on_down(self):
        r = self.current_row()
        if 0 <= r < self.model.rowCount() - 1:
            self.model.move_down(r)
            self.table.selectRow(r + 1)

    # ---- validation ----
    def validate_row(self, r: int) -> Tuple[bool, List[str]]:
        it = self.model.items()[r]
        errors = []
        name = it["name"].strip()
        pos = it["positive"].strip()
        neg = it["negative"].strip()

        if not name:
            errors.append("name が空です。")
        # 重複名チェック
        names = [x["name"] for x in self.model.items()]
        if names.count(name) > 1:
            errors.append("name が重複しています。")

        if not os.path.isdir(pos):
            errors.append(f"positive フォルダが存在しません: {pos}")
        elif not has_images(pos):
            errors.append(f"positive フォルダに画像が見つかりません: {pos}")

        if not os.path.isdir(neg):
            errors.append(f"negative フォルダが存在しません: {neg}")
        elif not has_images(neg):
            errors.append(f"negative フォルダに画像が見つかりません: {neg}")

        return (len(errors) == 0, errors)

    def on_validate_one(self):
        r = self.current_row()
        if r < 0:
            QtWidgets.QMessageBox.information(self, "情報", "検証する行を選択してください。")
            return
        ok, errs = self.validate_row(r)
        if ok:
            QtWidgets.QMessageBox.information(self, "OK", "選択行は有効です。")
        else:
            QtWidgets.QMessageBox.warning(self, "検証エラー", "- " + "\n- ".join(errs))

    def on_validate_all(self):
        if self.model.rowCount() == 0:
            QtWidgets.QMessageBox.information(self, "情報", "行がありません。")
            return
        all_ok = True
        messages = []
        for r in range(self.model.rowCount()):
            ok, errs = self.validate_row(r)
            if not ok:
                all_ok = False
                messages.append(f"[row {r+1}] " + " / ".join(errs))
        if all_ok:
            QtWidgets.QMessageBox.information(self, "OK", "全行とも有効です。")
        else:
            QtWidgets.QMessageBox.warning(self, "検証エラー", "- " + "\n- ".join(messages))

    # ---- file I/O ----
    def on_new(self):
        self.model.set_items([])
        self._json_path = ""
        self._base_dir_for_save = ""
        self.lbl_base_dir.setText("(未設定 → 現在の style.json の場所)")
        self.statusBar().showMessage("新規ドキュメント。")

    def on_open(self):
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "style.json を開く", "", "JSON (*.json)")
        if not path:
            return
        try:
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)
            items = normalize_loaded_json(data, base_dir=os.path.dirname(path))
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "読み込み失敗", str(e))
            return
        self.model.set_items(items)
        self._json_path = path
        self._base_dir_for_save = os.path.dirname(path)
        self.lbl_base_dir.setText(self._base_dir_for_save)
        self.statusBar().showMessage(f"読み込み: {path}")

    def _collect_items(self) -> List[Dict[str, str]]:
        # 編集パネルの変更を反映
        self.pull_editor_to_model()
        return self.model.items()

    def on_save(self):
        if not self._json_path:
            self.on_save_as()
            return
        self._save_to_path(self._json_path)

    def on_save_as(self):
        path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "style.json として保存", "style.json", "JSON (*.json)")
        if not path:
            return
        self._save_to_path(path)

    def _save_to_path(self, path: str):
        items = self._collect_items()
        base_dir = self._base_dir_for_save or os.path.dirname(path)
        make_relative = self._save_relative
        try:
            if self._save_as_list:
                out = export_as_list(items, base_dir, make_relative)
            else:
                out = export_as_dict(items, base_dir, make_relative)
            with open(path, "w", encoding="utf-8") as f:
                json.dump(out, f, ensure_ascii=False, indent=2)
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "保存失敗", str(e))
            return
        self._json_path = path
        if not self._base_dir_for_save:
            self._base_dir_for_save = os.path.dirname(path)
            self.lbl_base_dir.setText(self._base_dir_for_save)
        self.statusBar().showMessage(f"保存: {path}")

    def on_save_option_changed(self):
        self._save_as_list = self.chk_save_list.isChecked()
        self._save_relative = self.chk_relative.isChecked()

    def on_set_base_dir(self):
        d = QtWidgets.QFileDialog.getExistingDirectory(self, "相対パスの基準フォルダを選択")
        if d:
            self._base_dir_for_save = d
            self.lbl_base_dir.setText(d)
            self.statusBar().showMessage(f"相対基準フォルダを設定: {d}")

def main():
    app = QtWidgets.QApplication(sys.argv)
    font = app.font()
    font.setPointSize(10)
    app.setFont(font)
    win = MainWindow()
    win.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
